/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model. The vast
 * majority of data is nested within a user's private data tree, ensuring that users
 * can only access and manage their own information.
 *
 * Data Structure: The primary data organization is /users/{userId}/{subcollection},
 * which structurally isolates each user's data. Several top-level collections exist
 * for public or shared data, such as /tutoringsReviews (public reads) and /messages
 * (shared between participants).
 *
 * Key Security Decisions:
 * - Default Deny: All paths are closed by default. Access is only granted explicitly.
 * - Strict Ownership: For all data under /users/{userId}, only the authenticated
 *   user matching {userId} has any access. This includes their own profile, which
 *   is not publicly readable by other users as per the IR's description.
 * - No Public User Listing: Listing documents in the top-level `/users` collection is
 *   disabled to protect user privacy.
 * - Secure Queries: List operations on top-level collections containing private data
 *   (e.g., /favorites, /messages) are disabled. The data structure does not support
 *   a secure rule to guarantee users can only query their own documents. The
 *   recommended pattern for this data is to place it in a user-specific subcollection
 *   (e.g., /users/{userId}/favorites).
 *
 * Denormalization for Authorization: This ruleset relies on denormalized owner IDs
 * (e.g., `userId`, `driverId`, `organizerId`) on documents to perform fast and secure
 * authorization checks without needing costly `get()` calls to other documents.
 * For example, a rule on `/eventsAttendees/{id}` can directly check the `userId` field
 * on the document itself.
 *
 * Structural Segregation: User-private data (e.g., `housings`, `events`) is stored
 * in subcollections under `/users/{userId}`. This separation is more secure and
 * performant than using a single collection with a boolean flag, especially for list
 * operations. Publicly readable data like `/tutoringsReviews` is kept in a separate
 * top-level collection.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user is the owner of a document
     * based on the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
     * For state-changing operations (update, delete), ensures the document
     * already exists and the user is the owner.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * On create, validates that an ownership field in the new document data
     * matches the authenticated user's ID.
     */
    function incomingDataIsOwnedBy(ownerField) {
      return request.resource.data[ownerField] == request.auth.uid;
    }
    
    /**
     * On create, validates that an ownership field in the new document data
     * matches the userId from the document path.
     */
    function incomingDataMatchesUserPath(userId, ownerField) {
      return request.resource.data[ownerField] == userId;
    }

    /**
     * On update, ensures that a critical ownership or relational ID field
     * cannot be changed.
     */
    function isFieldImmutable(fieldName) {
      return request.resource.data[fieldName] == resource.data[fieldName];
    }

    // -------------------------------------------------------------------------
    // User Data
    // -------------------------------------------------------------------------

    /**
     * @description Stores user profile data. A user can create their own profile,
     *              and can only read or write their own document afterwards.
     * @path        /users/{userId}
     * @allow       (create) A new user creates their own profile document: `/users/user123` where auth.uid is `user123`.
     * @deny        (get) A different user tries to read a profile: `/users/user456` where auth.uid is `user123`.
     * @principle   Enforces strict self-access for a user's own profile document.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && isFieldImmutable('id');
      allow delete: if isExistingOwner(userId);

      /**
       * @description A user's housing listings. Only the owner can manage them.
       * @path        /users/{userId}/housings/{housingId}
       * @allow       (create) User `user123` creates a new housing listing under their own path.
       * @deny        (list) User `user456` tries to list housings for `user123`.
       * @principle   Restricts access to a user's own data tree (Ownership).
       */
      match /housings/{housingId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && incomingDataMatchesUserPath(userId, 'userId');
        allow update: if isExistingOwner(userId) && isFieldImmutable('userId');
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description A user's carpooling offers. Only the owner can manage them.
       * @path        /users/{userId}/carpoolings/{carpoolingId}
       * @allow       (get) User `user123` reads one of their carpooling offers.
       * @deny        (delete) User `user456` tries to delete a carpooling offer from `user123`.
       * @principle   Restricts access to a user's own data tree (Ownership).
       */
      match /carpoolings/{carpoolingId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && incomingDataMatchesUserPath(userId, 'driverId');
        allow update: if isExistingOwner(userId) && isFieldImmutable('driverId');
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description A user's carpool bookings. Only the owner can manage them.
       * @path        /users/{userId}/carpoolBookings/{carpoolBookingId}
       * @allow       (create) User `user123` books a carpool, creating a booking record for themselves.
       * @deny        (update) User `user456` tries to update a booking made by `user123`.
       * @principle   Restricts access to a user's own data tree (Ownership).
       */
      match /carpoolBookings/{carpoolBookingId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && incomingDataMatchesUserPath(userId, 'passengerId');
        allow update: if isExistingOwner(userId) && isFieldImmutable('passengerId');
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description A user's tutoring services. Only the owner can manage them.
       * @path        /users/{userId}/tutorings/{tutoringId}
       * @allow       (list) User `user123` lists all tutoring services they offer.
       * @deny        (create) User `user456` tries to create a tutoring service under `user123`'s path.
       * @principle   Restricts access to a user's own data tree (Ownership).
       */
      match /tutorings/{tutoringId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && incomingDataMatchesUserPath(userId, 'tutorId');
        allow update: if isExistingOwner(userId) && isFieldImmutable('tutorId');
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description A user's created events. Only the owner can manage them.
       * @path        /users/{userId}/events/{eventId}
       * @allow       (update) User `user123` updates an event they organized.
       * @deny        (get) User `user456` tries to read event data directly from `user123`'s private collection.
       * @principle   Restricts access to a user's own data tree (Ownership).
       */
      match /events/{eventId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && incomingDataMatchesUserPath(userId, 'organizerId');
        allow update: if isExistingOwner(userId) && isFieldImmutable('organizerId');
        allow delete: if isExistingOwner(userId);
      }
    }
    
    // -------------------------------------------------------------------------
    // Top-Level Collections
    // -------------------------------------------------------------------------
    
    /**
     * @description Stores reviews for tutoring services. Reads are public, but
     *              only the authenticated author can create, update, or delete their own review.
     * @path        /tutoringsReviews/{tutoringReviewId}
     * @allow       (create) Any authenticated user creates a review, setting `studentId` to their own UID.
     * @deny        (update) User `user456` tries to change a review written by `user123`.
     * @principle   Public read access, but writes are restricted to the document owner (`studentId`).
     */
    match /tutoringsReviews/{tutoringReviewId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && incomingDataIsOwnedBy('studentId');
      allow update: if isExistingOwner(resource.data.studentId) && isFieldImmutable('studentId');
      allow delete: if isExistingOwner(resource.data.studentId);
    }
    
    /**
     * @description Stores records of users attending events. Reads are public, but
     *              only the user themselves can create or delete their attendance record.
     * @path        /eventsAttendees/{eventAttendeeId}
     * @allow       (create) User `user123` creates an attendance record with `userId` set to their own UID.
     * @deny        (delete) User `user456` tries to remove `user123` from an event's attendee list.
     * @principle   Public read access, but writes are restricted to the document owner (`userId`).
     */
    match /eventsAttendees/{eventAttendeeId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && incomingDataIsOwnedBy('userId');
      allow update: if isExistingOwner(resource.data.userId) && isFieldImmutable('userId');
      allow delete: if isExistingOwner(resource.data.userId);
    }
    
    /**
     * @description Stores private messages. Only the sender or receiver can read a message.
     *              Only the sender can create, update or delete it. Listing is disallowed for security.
     * @path        /messages/{messageId}
     * @allow       (get) User `user456` (the receiver) reads a message sent by `user123`.
     * @deny        (list) Any user tries to list all messages in the collection.
     * @principle   Restricts access to participants of a conversation.
     */
    match /messages/{messageId} {
      allow get: if isSignedIn() && resource != null && (request.auth.uid == resource.data.senderId || request.auth.uid == resource.data.receiverId);
      allow list: if false; // List is denied for security; client should query based on senderId or receiverId.
      allow create: if isSignedIn() && incomingDataIsOwnedBy('senderId');
      allow update: if isExistingOwner(resource.data.senderId) && isFieldImmutable('senderId') && isFieldImmutable('receiverId');
      allow delete: if isExistingOwner(resource.data.senderId);
    }
    
    /**
     * @description Stores a user's favorite items. This is private data; only the
     *              user can manage and view their own favorites.
     * @path        /favorites/{favoriteId}
     * @allow       (create) User `user123` creates a new favorite, setting `userId` to their own UID.
     * @deny        (get) User `user456` tries to read one of `user123`'s favorites.
     * @principle   Enforces strict document ownership for all operations on sensitive user data.
     */
    match /favorites/{favoriteId} {
      allow get: if isExistingOwner(resource.data.userId);
      allow list: if false; // List is denied. This structure is not secure for list queries. Use a user subcollection instead.
      allow create: if isSignedIn() && incomingDataIsOwnedBy('userId');
      allow update: if isExistingOwner(resource.data.userId) && isFieldImmutable('userId');
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Stores OAuth provider links for user accounts. This is highly sensitive
     *              and strictly limited to the user who owns the link.
     * @path        /oauthProviders/{oAuthProviderId}
     * @allow       (create) User `user123` links their Google account, creating a provider document owned by them.
     * @deny        (list) Any user tries to list all OAuth provider links in the system.
     * @principle   Enforces strict ownership for sensitive authentication data.
     */
    match /oauthProviders/{oAuthProviderId} {
      allow get: if isExistingOwner(resource.data.userId);
      allow list: if false;
      allow create: if isSignedIn() && incomingDataIsOwnedBy('userId');
      allow update: if isExistingOwner(resource.data.userId) && isFieldImmutable('userId');
      allow delete: if isExistingOwner(resource.data.userId);
    }
  }
}