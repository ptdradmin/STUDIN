/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model for all
 * write operations. A user can only create, update, or delete their own data.
 * Publicly browsable content (like housing, carpooling, tutoring, and events)
 * is publicly readable to allow for discovery, while personal data (like user
 * profiles, favorites, and event attendance) is kept private.
 *
 * Data Structure: The data is organized hierarchically. Most data is stored in
 * subcollections under the `/users/{userId}` path. This structure inherently
 * links data to its owner, simplifying security rules. A top-level `/messages`
 * collection is used for direct messages, with security based on internal fields.
 *
 * Key Security Decisions:
 * - User Profile (`/users/{userId}`): A user can only manage their own profile.
 *   Profiles can be read by any signed-in user to facilitate interaction (e.g.,
 *   viewing a housing lister's profile), but user enumeration via `list` is disabled.
 * - Public Listings (`housing`, `carpooling`, `tutoring`, `events`): These
 *   collections are publicly readable (`get`, `list`) to allow any user or
 *   visitor to browse them. However, write access (`create`, `update`, `delete`)
 *   is strictly limited to the user who owns the data. This is enforced using
 *   the `userId` in the path.
 * - Private User Data (`favorites`, `eventAttendees`): These subcollections
 *   are considered private. Both read and write access are restricted to the
 *   data owner.
 * - Messages (`/messages`): Messages are private and can only be read by the
 *   sender or receiver. They are immutable; updates and deletes are disallowed.
 *   Listing the entire `messages` collection is disabled for security and
 *   performance reasons.
 *
 * Denormalization for Authorization: Authorization relies on path-based security
 * (e.g., `isOwner(userId)` checks the path) and denormalized ownership fields
 * within documents (e.g., `resource.data.organizerId`). For user-owned
 * subcollections, we validate on creation that the internal ownership ID (e.g.,
 * `userId`, `tutorId`) matches the `userId` from the path, ensuring relational
 * integrity.
 *
 * Structural Segregation: User-specific data is segregated into distinct
 * subcollections under `/users/{userId}`. This creates homogenous security
 * boundaries, where all documents in a collection share the same access control
 * rules, making the ruleset simpler and more secure.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * Returns true if the user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the requesting user's UID matches the provided userId.
     * This is the primary function for checking document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the user is the owner and the document already exists.
     * Used for safe update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates that the owner ID field in a new document matches the owner's UID.
     * Enforces relational integrity on create.
     * @param data The incoming request resource data.
     * @param ownerField The name of the field containing the owner's UID (e.g., 'userId', 'driverId').
     */
    function isCorrectOwnerOnCreate(data, ownerField) {
        return data[ownerField] == request.auth.uid;
    }

    /**
     * Validates that an owner ID field has not been changed during an update.
     * Enforces immutability of ownership.
     * @param ownerField The name of the field containing the owner's UID.
     */
    function isOwnerFieldImmutable(ownerField) {
        return request.resource.data[ownerField] == resource.data[ownerField];
    }

    // -------------------------------------------------------------------------
    // User Profiles (/users/{userId})
    // -------------------------------------------------------------------------

    /**
     * @description Manages user profiles. A user can create, update, and delete
     *   their own profile. Any signed-in user can view a profile, but listing
     *   all users is disallowed to prevent user enumeration.
     * @path /users/{userId}
     * @allow (get) Any signed-in user viewing another user's profile.
     * @allow (create) A new user signing up and creating their own profile document. `auth.uid` must match `{userId}`.
     * @deny (list) An anonymous or signed-in user trying to list all users.
     * @deny (update) A user trying to modify another user's profile.
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isSignedIn();
      allow list: if false;
      allow create: if isOwner(userId) && isCorrectOwnerOnCreate(request.resource.data, 'id');
      allow update: if isExistingOwner(userId) && isOwnerFieldImmutable('id');
      allow delete: if isExistingOwner(userId);

      // -----------------------------------------------------------------------
      // Housing Listings (/users/{userId}/housing/{housingId})
      // -----------------------------------------------------------------------

      /**
       * @description Manages housing listings. Listings are public to read for
       *   all users to allow browsing. Only the user who created the listing
       *   can create, update, or delete it.
       * @path /users/{userId}/housing/{housingId}
       * @allow (get, list) Any user, signed-in or not, viewing housing listings.
       * @allow (create) A signed-in user creating a new housing listing under their own user ID.
       * @deny (update) A user trying to modify a housing listing they do not own.
       * @principle Enforces public read access with strict document ownership for writes.
       */
      match /housing/{housingId} {
        allow get: if true;
        allow list: if true;
        allow create: if isOwner(userId) && isCorrectOwnerOnCreate(request.resource.data, 'userId');
        allow update: if isExistingOwner(userId) && isOwnerFieldImmutable('userId');
        allow delete: if isExistingOwner(userId);
      }

      // -----------------------------------------------------------------------
      // Carpooling Offers (/users/{userId}/carpooling/{carpoolingId})
      // -----------------------------------------------------------------------

      /**
       * @description Manages carpooling offers. Offers are public to read for
       *   all users. Only the driver (owner) can create, update, or delete their offers.
       * @path /users/{userId}/carpooling/{carpoolingId}
       * @allow (get, list) Any user browsing available carpooling trips.
       * @allow (create) A signed-in user (driver) posting a new trip under their own ID.
       * @deny (delete) A user trying to cancel a trip they are not the driver of.
       * @principle Enforces public read access with strict document ownership for writes.
       */
      match /carpooling/{carpoolingId} {
        allow get: if true;
        allow list: if true;
        allow create: if isOwner(userId) && isCorrectOwnerOnCreate(request.resource.data, 'driverId');
        allow update: if isExistingOwner(userId) && isOwnerFieldImmutable('driverId');
        allow delete: if isExistingOwner(userId);
      }

      // -----------------------------------------------------------------------
      // Tutoring Offers (/users/{userId}/tutoring/{tutoringId})
      // -----------------------------------------------------------------------

      /**
       * @description Manages tutoring offers. Offers are public to read for
       *   all users. Only the tutor (owner) can create, update, or delete their offers.
       * @path /users/{userId}/tutoring/{tutoringId}
       * @allow (get, list) Any user browsing available tutors.
       * @allow (create) A signed-in tutor creating a new offer under their own ID.
       * @deny (update) A user trying to change the details of another tutor's offer.
       * @principle Enforces public read access with strict document ownership for writes.
       */
      match /tutoring/{tutoringId} {
        allow get: if true;
        allow list: if true;
        allow create: if isOwner(userId) && isCorrectOwnerOnCreate(request.resource.data, 'tutorId');
        allow update: if isExistingOwner(userId) && isOwnerFieldImmutable('tutorId');
        allow delete: if isExistingOwner(userId);
      }

      // -----------------------------------------------------------------------
      // Events (/users/{userId}/events/{eventId})
      // -----------------------------------------------------------------------

      /**
       * @description Manages user-created events. Events are public to read for
       *   all users. Only the event organizer (owner) can create, update, or delete their events.
       * @path /users/{userId}/events/{eventId}
       * @allow (get, list) Any user browsing upcoming events.
       * @allow (create) A signed-in user creating a new event under their own ID.
       * @deny (update) A user trying to modify an event they did not organize.
       * @principle Enforces public read access with strict document ownership for writes.
       */
      match /events/{eventId} {
        allow get: if true;
        allow list: if true;
        allow create: if isOwner(userId) && isCorrectOwnerOnCreate(request.resource.data, 'organizerId');
        allow update: if isExistingOwner(userId) && isOwnerFieldImmutable('organizerId');
        allow delete: if isExistingOwner(userId);
      }

      // -----------------------------------------------------------------------
      // Event Attendees (/users/{userId}/eventAttendees/{eventAttendeeId})
      // -----------------------------------------------------------------------

      /**
       * @description Manages a user's attendance status for events. This data is
       *   private and can only be accessed by the user themselves.
       * @path /users/{userId}/eventAttendees/{eventAttendeeId}
       * @allow (get, list, create) A signed-in user viewing or managing their own event attendance.
       * @deny (get) A user trying to see if another user is attending an event.
       * @principle Restricts access to a user's own private data.
       */
      match /eventAttendees/{eventAttendeeId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && isCorrectOwnerOnCreate(request.resource.data, 'userId');
        allow update: if isExistingOwner(userId) && isOwnerFieldImmutable('userId');
        allow delete: if isExistingOwner(userId);
      }

      // -----------------------------------------------------------------------
      // Favorites (/users/{userId}/favorites/{favoriteId})
      // -----------------------------------------------------------------------

      /**
       * @description Manages a user's list of favorite items. This data is
       *   private and can only be accessed by the user themselves.
       * @path /users/{userId}/favorites/{favoriteId}
       * @allow (get, list, create, delete) A signed-in user managing their own list of favorites.
       * @deny (get) A user trying to view another user's favorites.
       * @principle Restricts access to a user's own private data.
       */
      match /favorites/{favoriteId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && isCorrectOwnerOnCreate(request.resource.data, 'userId');
        allow update: if isExistingOwner(userId) && isOwnerFieldImmutable('userId');
        allow delete: if isExistingOwner(userId);
      }
    }

    // -------------------------------------------------------------------------
    // Messages (/messages/{messageId})
    // -------------------------------------------------------------------------

    /**
     * @description Manages direct messages between users. A message can only be
     *   read by its sender or receiver. Only the sender can create a message.
     *   Messages are immutable (no updates or deletes). Listing is disabled.
     * @path /messages/{messageId}
     * @allow (get) The sender or receiver of the message reading it.
     * @allow (create) The sender creating a new message.
     * @deny (get) A third-party user trying to read a private conversation.
     * @deny (list) Any user trying to list all messages in the database.
     * @principle Enforces access control for data shared between specific users.
     */
    match /messages/{messageId} {
      allow get: if isSignedIn() && (request.auth.uid == resource.data.senderId || request.auth.uid == resource.data.receiverId);
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.senderId == request.auth.uid;
      allow update: if false;
      allow delete: if false;
    }
  }
}